# mastodon-docker-compose

The goal of this repo is to provide a simple way to configure and deploy an instance of Mastodon using a released image (vs. building your own).

The official Mastodon Github repository at https://github.com/mastodon/mastodon has a `docker-compose.yml` file but I found that it could be optimized more for my liking. My goals were to move all of the editable configuration into `.env` and leave the `docker-compose.yml` file as generic as possible across all use cases.

## Mastodon Version Support

NOTE: The current version of this docker-compose file and setup instructions supports Mastodon v4.3.0 and later! See the `pre-v4.3.0` folder for earlier versions.

## Prequisites:
- Docker-compose v2 or newer
- A containerized nginx-proxy, we recommend https://github.com/nginx-proxy/nginx-proxy along with https://github.com/nginx-proxy/acme-companion for LetsEncrypt automation. 

I would like to publish my nginx setup as well, but who knows when I will get to it.  If you use a non-dockerized nginx to front-end your site, you'll have to work out those changes yourself.

## Prepare your environment

Clone this repository and then rename the directory to whatever you like, probably representing the name of the Mastodon instance (especially if you want to run several different instances)

CD to the directory and edit the `.env` file to reflect all of your settings. Pay attention to S3 and CDN settings: These must be up and running and tested prior to configuring Mastodon. This setup does not (and cannot) create and manage these external systems!

Next, after saving `.env` and ensuring that `.env.production` is a symlink of `.env`, then run these commands to prep the filesystem:

First, let's pull in `.env` so that subsequent commands run in the same shell pick up the settings.
```
source .env
```

Next, create the "internal" network for Mastodon (strictly speaking, this is a Docker "external" network which means it is managed external to the deployment/project. For our purposes, it's "internal" because it is not exposed to the internet)

```
docker network create --internal "${INTERNAL_NETWORK}"
```

Prepare directory for elastic https://www.elastic.co/guide/en/elasticsearch/reference/master/docker.html

```
sudo mkdir -p ./elasticsearch/data
sudo mkdir -p ./elasticsearch/logs
sudo chmod -R g+rwx ./elasticsearch
sudo chgrp -R 0 ./elasticsearch
```

Prepare public directory for proper permissions
```
sudo mkdir -p ./public/system
sudo chown -R 991:991 ./public
sudo chmod -R 755 ./public
```

Prepare host for elastic. https://www.elastic.co/guide/en/elasticsearch/reference/master/docker.html
Increase vm.max_map_count to at least 262144 (prevents crash in elastic)
```
sudo sysctl -w vm.max_map_count=262144 
sudo echo "vm.max_map_count = 262144" > /etc/sysctl.d/11.mastodon.conf
```

Generate your secrets and add them to the `.env` before continuing!:
```
# Run to generate the VAPID public and private keys and add to .env, without clobbering anything in there
docker-compose run --rm web bundle exec rake mastodon:webpush:generate_vapid_key

# Run to generate the ACTIVE_RECORD_ENCRYPTION keys and add to .env, without clobbering anything in there
docker-compose run --rm web bundle exec bin/rails db:encryption:init

# Run twice for secrets, once for OTP_SECRET and once for SECRET_KEY_BASE, and add to .env, without clobbering anything in there
docker-compose run --rm web bundle exec bin/rails secret
docker-compose run --rm web bundle exec bin/rails secret
```

Did you update `.env` per above? Good! Continue...

## Initialize your system

Finalize the database migrations, deploy search, and initialize your admin user:
```
# Finalize any database migration
docker-compose run --rm web rails db:migrate

# Start everything
docker-compose up -d

# Initialize Elastic Search
docker-compose run --rm web bin/tootctl search deploy --only=accounts

# Create the admin user. The password is shown, but this user can also use password recovery to log in.
docker-compose run --rm web bin/tootctl account create "${ADMIN_USER}" --email="${ADMIN_EMAIL}" --confirmed --role=Owner --approve
```
## Access your site

You should now be able to go to your site and log in as admin with the password generated by the script above, or use the "Forgot Password" to recover and reset your admin password.

